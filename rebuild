#!/bin/sh -eu

trap _cleanup EXIT
_cleanup() { [ -d "${T:-}" ] && rm -rf "$T"; echo I CLEAN GOOD YOU PAY $T; }
_err() { local c="$1"; shift; echo >&2 "${0##*/}: $*"; exit "$c"; }

_dir="${XDG_RUNTIME_DIR:-${TMP:-/tmp}}"
T="$(mktemp -d "${_dir}/${0##*/}.XXXXXX" 2>/dev/null || true)"
_pipe="$T/pipe"

[ -d "${T:-}" ] || _err 1 "temp no exist"

mkfifo "$T/pipe" || _err 1 "pipe no exist"

# TODO build dir parametric
# TODO build dir in tmp in mem outside project

# CDPATH apparently causes unexpected 'cd' output on some platforms.
# from redo/minimal
#unset CDPATH

alias Q='>/dev/null'

MARK() { touch -m -t 0001010000 "$1"; }
# MARK() { rm -fv "$1"; }

DO() {
	local cmd="build/$1"; shift
	[ -f "$cmd" ] || _err 1 "command no exist: $1"
	[ -x "$cmd" ] || _err 1 "command no exec: $1"
	"$cmd" "$@"
}

# _yargs() {
# 	while read x; do set -- "$@" "$x"; done
# 	"$@"
# }

RUN() {
	local msg="$1"; shift
	if Q "$@"; then echo "$msg"; else _err $? "$*"; fi
	# better 2>null and in case of error repeat command again to show it

}

FIND() {
	if [ -e "$1" ]; then echo "$1"
	elif [ -e "build/$1" ]; then echo "build/$1"	
	else _err 1 "dep not found: $1"
	fi
}

OK() {
	local t="$1" code=0 d; shift
	for d; do
 		[ "$t" -ef "$d" ] && continue

		# echo CHECK $d for $t # delme
 		# flock -s -n "$d" -c true || echo WAIT ON $d for $t # delme
		flock -s "$d" -c true
		# echo ACCESS $d for $t # delme
  				
		[ "$d" -nt "$t" ] && code=1
	done

	return $code
}

LOCK() {
	: ${_fd:=3}
	for t; do
		if [ -e "$t" ]; then
			eval "exec $_fd< '$t'"
		else
			eval "exec $_fd> '$t'"
			MARK "$t"
		fi
		flock -n $_fd
 		# echo LOCK "$t" # delme
		_fd=$((_fd+1))
	done
	echo good >> $_pipe
}

RLOCK() {
	: ${_fd:=3}
	: ${_rfd:=$_fd}
	for t; do
		[ -e "$t" ] || _err 5 "RLOCK: no exist: $t"
		eval "exec $_fd< '$t'"
		flock -s $_fd
 		# echo RLOCK "$t" # delme
		_fd=$((_fd+1))
	done
}

RUNLOCK() {
	local _xrfd=$_rfd
	for t; do
		flock -u $_xrfd
 		# echo RUNLOCK "$t" # delme
		_xrfd=$((_xrfd+1))
	done
}

_cc() { RUN "c $1" ${CC:-cc} ${CFLAGS:-} -c -o "$@"; }
_ld() { RUN "l $1" ${CC:-cc} ${CFLAGS:-} ${LDFLAGS:-} -o "$@"; }

LD() {
	local t="build/$1"; shift
	(
		LOCK "$t"
		OK "$t" "$@" || _ld "$t" "$@"
	) &
	read < $_pipe
}

CC() {
	local h o n c b;
	for f; do
		c="$(FIND "$f")"
		n="${c##*/}"
		b="${n%.c}.o"
	    o="build/${n%.c}.o"
		(
			LOCK "$o"
			RLOCK "$c"

			set --
			for h in $(${CPP:-cpp} ${CFLAGS:-} -MM -MG "$c"); do
				case "$h" in (\\|"$b:") continue;; esac
				set -- "$@" "$h"
			done

			RUNLOCK "$c"
			OK "$o" "$c" "$@" || _cc "$o" "$c"
		) &
		read < $_pipe
	done
}

CP() { OK "$2" "$1" || { RUN "+ $2" cp "$1" "$2"; } }

PG() {
	local p="$1"
	local b="${p##*/}"
	local c="build/${b%.peg}.c" h="build/${b%.peg}.h"
	(
		LOCK "$c" "$h"

		# flock -s -n build/packcc -c true || echo WAIT build/packcc # delme
		flock -s build/packcc -c true
		# echo ACCESS build/packcc # delme

		OK "$c" "$p" || { cd build/; ./packcc -o "${b%.peg}" ../"$p"; echo p "$p"; }
	) &
	read < $_pipe
}

/bin/sh -n ./buildfile
. ./buildfile

Q command -v clean || clean() { RUN '- build/' rm -rf build/; } 

[ $# -gt 0 ] || set -- build

for arg; do
	Q command -v "$arg" || _err 8 "no such target: $arg"
	eval "$arg"
	wait
done

