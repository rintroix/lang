#!/bin/sh -eu

# PS4='+ $(date "+%s.%N")\011 '
# exec 2>/tmp/bashstart.$$.log
# set -x

: ${P:=''}
: ${D:=''}

trap _cleanup EXIT
_cleanup() { [ -d "${T:-}" ] && rm -rf "$T"; echo I CLEAN GOOD YOU PAY $T; }
_err() { local c="$1"; shift; echo >&2 "${0##*/}: $*"; exit "$c"; }

_dir="${XDG_RUNTIME_DIR:-${TMP:-/tmp}}"
T="$(mktemp -d "${_dir}/${0##*/}.XXXXXX" 2>/dev/null || true)"

[ -d "${T:-}" ] || _err 1 "temp no exist"

debug() { [ "$D" ] || return 0; echo >&2 "$@"; }

# TODO build dir parametric
# TODO build dir in tmp in mem outside project

# CDPATH apparently causes unexpected 'cd' output on some platforms.
# from redo/minimal
unset CDPATH

alias Q='>/dev/null'

MARK() { touch -m -t 0001010000 "$1"; }
# MARK() { rm -fv "$1"; }

DO() {
	local cmd="build/$1"; shift
	WANT "$cmd"
	[ -f "$cmd" ] || _err 1 "command no exist: $cmd"
	[ -x "$cmd" ] || _err 1 "command no exec: $cmd"
	"$cmd" "$@"
}

RUN() {
	if Q "$@"; then :; else _err $? "$*"; fi
	# better 2>null and in case of error repeat command again to show it
}

FIND() {
	if [ -e "$1" ]; then echo "$1"
	elif [ -e "build/$1" ]; then echo "build/$1"	
	else _err 1 "dep not found: $1"
	fi
}

OK() {
	local t="$1" code=0 d; shift
	for d; do
 		[ "$t" -ef "$d" ] && continue
		WANT "$d"
		[ "$d" -nt "$t" ] && code=1
	done
	return $code
}

_lock() {
	local fd="$1" f="$2"
	if [ -e "$f" ]; then
		eval "exec $fd< '$f'"
		debug LOCK R "$f" on $fd
	else
		eval "exec $fd> '$f'"
		debug LOCK W "$f" on $fd
		MARK "$f"
	fi
	flock -n $fd || _err 8 "lock failed: $f" 
}

WANT() {
	[ "$P" ] || return 0
	debug WANT $1
	exec 9< "$1" || _err 5 "WANT: no access: $1"
	flock -s 9
	exec 9<&-
	debug ACCESS $1
}

LD() {
	local t="build/$1"; shift
	ls -al build/
	OK "$t" "$@" && return
	RRR1 "$t" $CC $CFLAGS $LDFLAGS -o "$t" "$@"
}

RE() {
	local rule="_rule_${1##*.}"
	Q command -v "$rule" || _err 8 "no rule for: $1"
	"$rule" "$@"
}

_rule_c() {
	local h o n c b;
	c="$(FIND "$1")"
	n="${c##*/}"
	b="${n%.c}.o"
    o="build/${n%.c}.o"

	WANT "$c"

	set --
	for h in $($CPP $CFLAGS -MM -MG "$c"); do
		case "$h" in
			(\\|"$b:") continue;;
		esac
		set -- "$@" "$h"
	done

	OK "$o" "$c" "$@" && return
	RRR1 "$o" $CC $CFLAGS -c -o "$o" "$c"
}

_rule_peg() {
	local p="$1" b="${1##*/}"
	local c="build/${b%.peg}.c" h="build/${b%.peg}.h"
	WANT build/packcc

	OK "$c" "$p" && return
	RRRN "$c" "$h" % _peg "$p" "${b%.peg}"
}

_peg() {
	( cd build/; ./packcc -o "$2" ../"$1"; echo p "$1"; )
}

RRR1() {
	local t="$1"; shift
	RRRN "$t" % "$@"
}

RRRN() {
	debug RRRN "$@"
	local n=3
	if [ "$P" ]; then
		exec 9< "$0"; flock 9
		( 
			while [ "$1" != "%" ]; do
				_lock $n "$1"
				n=$((n + 1))
				echo + "$1"
				shift
			done
			shift # %

			flock -u 9
			"$@"
			debug RRR DONE "$@"
		) &
		exec 8< "$0"; flock -s 8
		exec 8<&- 9<&-
		debug CARRY ON RRR "$@"
	else
		while [ "$1" != "%" ]; do
			echo + "$1"
			shift
		done
		shift # %
		"$@"
		debug RRR DONE "$@"
	fi
}

/bin/sh -n ./buildfile
. ./buildfile

: ${CC:=cc}
: ${CPP:=cpp}
: ${CFLAGS:=}
: ${LDFLAGS:=}

Q command -v clean || clean() { rm -rf build/; echo '- build/'; } 

[ $# -gt 0 ] || set -- build

for arg; do
	Q command -v "$arg" || _err 8 "no such target: $arg"
	eval "$arg"
	wait
done

