#!/bin/sh -eu

# PS4='+ $(date "+%s.%N")\011 '
# exec 2>/tmp/bashstart.$$.log
# set -x

: ${P:=''}
: ${D:=''}

TARGETS=""
LASTLOCK=""
PARENTPID="$$"

trap _cleanup EXIT
_cleanup() { [ -d "${T:-}" ] && rm -rf "$T"; echo I CLEAN GOOD YOU PAY $T; }
_err() { local c="$1"; shift; echo >&2 "${0##*/}: $*"; kill -INT "-$PARENTPID"; }

_dir="${XDG_RUNTIME_DIR:-${TMP:-/tmp}}"
T="$(mktemp -d "${_dir}/${0##*/}.XXXXXX" 2>/dev/null || true)"

[ -d "${T:-}" ] || _err 1 "temp no exist"

debug() { [ "$D" ] || return 0; echo >&2 "$@"; }

# TODO build dir parametric
# TODO build dir in tmp in mem outside project

# CDPATH apparently causes unexpected 'cd' output on some platforms.
# from redo/minimal
unset CDPATH

alias Q='>/dev/null'

MARK() { touch -m -t 0001010000 "$1"; }
# MARK() { rm -fv "$1"; }

DO() {
	local cmd="build/$1"; shift
	debug DO "$cmd" "$@"
	WANT "$cmd"
	[ -f "$cmd" ] || _err 1 "command no exist: $cmd"
	[ -x "$cmd" ] || _err 1 "command no exec: $cmd"
	"$cmd" "$@"
}

RUN() {
	if Q "$@"; then :; else _err $? "$*"; fi
	# better 2>null and in case of error repeat command again to show it
}

FIND() {
	if [ -e "$1" ]; then echo "$1"
	elif [ -e "build/$1" ]; then echo "build/$1"	
	else _err 1 "dep not found: $1"
	fi
}

OK() {
	local t="$1" code=0 d; shift
	echo OK "$@"
	[ -e "$t" ] || code=1
	for d; do
 		[ "$t" -ef "$d" ] && _err 8 "same file in ok: $t vs $d"
		WANT "$d"
		[ $code -eq 0 -a "$d" -nt "$t" ] && code=1
	done

	return $code
}

LOCK() {
	local f
	LASTLOCK=""
	for f; do
		TARGETS="${TARGETS}${f}:"
		LASTLOCK="${LASTLOCK}${f}:"
	done
}

_lock() {
	: ${fd:=3}
	local fd=3 f IFS=:
	for f in $LASTLOCK; do
		mkdir -p "$T/$f"
		eval "exec $fd< '$T/$f'"
		flock -n $fd || _err 8 "lock failed: $f" 
		debug LOCK "$f"
		: $(( fd++ ))
	done
}

WANT() {
	[ "$P" ] || return 0
	local IFS=:
	debug WANT $1
	for t in $TARGETS; do
		[ "$t" = "$1" -a -e "$T/$1" ] || continue
		exec 55< "$T/$1" || _err 5 "WANT: no access: $1"
		debug WAIT $1
		flock -s 55
		exec 55<&-
		break
	done
	debug ACCESS $1
}

LD() {
	local t="$BUILD/$1"; shift
	debug LD "$t" "$@"
	LOCK "$t"
	OK "$t" "$@" ||    
		RRR $CC $CFLAGS $LDFLAGS -o "$t" "$@"
}

RE() {
	local rule="_rule_${1##*.}"
	Q command -v "$rule" || _err 8 "no rule for: $1"
	"$rule" "$@"
}

_map() {
	local cmd="$1"; shift
	
}

_rule_c() {
	local h o n c b;
	c="$(FIND "$1")"
	n="${c##*/}"
	b="${n%.c}.o"
    o="build/${n%.c}.o"

	LOCK "$o" 
	WANT "$c"

	set --
	for h in $($CPP $CFLAGS -MM -MG "$c"); do
		case "$h" in
			(\\|"$b:"|"$c") continue;;
		esac
		set -- "$@" "$h"
	done

	OK "$o" "$c" "$@" ||
		RRR $CC $CFLAGS -c -o "$o" "$c"
}

_rule_peg() {
	local p="$1" b="${1##*/}"
	local c="build/${b%.peg}.c" h="build/${b%.peg}.h"

	LOCK "$c" "$h"
	WANT build/packcc

	OK "$c" "$p" ||
		RRR _peg "$p" "${b%.peg}"
}

_peg() {
	(
		cd build/
		./packcc -o "$2" ../"$1" || _err 8 "packcc"
	)
}

ARM() {
	exec 9< "$0"
	flock 9
}

UNARM() {
	flock -u 9
}

WAIT() {
	exec 8< "$0"
	flock -s 8
	exec 8<&- 9<&-
}

RRR() {
	debug RRR "$@"
	if [ "$P" ]; then
		ARM
		( 
			_lock
			UNARM
			"$@" || _err 8 "RRR: $*"
			debug RRR DONE "$@"
		) &
		WAIT
		debug CARRY ON RRR "$@"
	else
		"$@" || _err 8 "RRR: $*"
		debug RRR DONE "$@"
	fi
}

/bin/sh -n ./buildfile
. ./buildfile

: ${CC:=cc}
: ${CPP:=cpp}
: ${CFLAGS:=}
: ${LDFLAGS:=}
: ${BUILD:=build}

Q command -v clean || clean() { rm -rf build/; echo '- build/'; } 

[ $# -gt 0 ] || set -- build

for arg; do
	Q command -v "$arg" || _err 8 "no such target: $arg"
	eval "$arg"
	wait
done

